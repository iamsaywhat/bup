/*---------------------------------------------------------------------------/
/  FatFs Functional Configurations
/---------------------------------------------------------------------------*/

#define FFCONF_DEF	86604	/* Revision ID */

/*---------------------------------------------------------------------------/
/ Конфигурация функций
/---------------------------------------------------------------------------*/

#define FF_FS_READONLY	0
/* Эта опция переключает конфигурацию только для чтения. (0: чтение / запись или 1: только чтение)
/ Только для чтения конфигурация удаляет функции записи API, f_write (), f_sync (),
/ f_unlink (), f_mkdir (), f_chmod (), f_rename (), f_truncate (), f_getfree ()
/ и дополнительные функции записи. */


#define FF_FS_MINIMIZE	0
/* Эта опция определяет уровень минимизации для удаления некоторых основных функций API.
/
/ 0: Основные функции полностью включены.
/ 1: f_stat (), f_getfree (), f_unlink (), f_mkdir (), f_truncate () и f_rename ()
/ удалены.
/ 2: f_opendir (), f_readdir () и f_closedir () удаляются в дополнение к 1.
/ 3: функция f_lseek () удалена в дополнение к 2. */


#define FF_USE_STRFUNC	0
/* Эта опция переключает строковые функции, f_gets (), f_putc (), f_puts () и f_printf ().
/
/ 0: отключить строковые функции.
/ 1: Включить без преобразования LF-CRLF.
/ 2: Включить с преобразованием LF-CRLF. */


#define FF_USE_FIND		0
/* Эта опция переключает функции чтения отфильтрованных каталогов, f_findfirst () и
/ f_findnext (). (0: отключить, 1: включить 2: включить с соответствующим altname [] тоже */

#define FF_USE_MKFS		0
/* Эта опция переключает функцию f_mkfs (). (0: отключить или 1: включить) */


#define FF_USE_FASTSEEK	0
/* Эта опция переключает функцию быстрого поиска. (0: отключить или 1: включить) */


#define FF_USE_EXPAND	0
/* Эта опция переключает функцию f_expand. (0: отключить или 1: включить) */


#define FF_USE_CHMOD	0
/* Эта опция переключает функции управления атрибутами, f_chmod () и f_utime ().
/ (0: отключить или 1: включить) Также FF_FS_READONLY должно быть 0, чтобы включить эту опцию. */


#define FF_USE_LABEL	0
/* Эта опция переключает функции меток томов, f_getlabel () и f_setlabel ().
/ (0: отключить или 1: включить) */


#define FF_USE_FORWARD	0
/* Эта опция переключает функцию f_forward (). (0: отключить или 1: включить) */


/*---------------------------------------------------------------------------/
/ Locale and Namespace Configurations
/---------------------------------------------------------------------------*/

#define FF_CODE_PAGE	932
/* Эта опция указывает кодовую страницу OEM, которая будет использоваться в целевой системе.
/ Неправильная настройка кодовой страницы может привести к ошибке открытия файла.
/
/ 437 - США
/ 720 - арабский
/ 737 - греческий
/ 771 - KBL
/ 775 - Балтика
/ 850 - латинский 1
/ 852 - латинский 2
/ 855 - кириллица
/ 857 - турецкий
/ 860 - португальский
/ 861 - исландский
/ 862 - иврит
/ 863 - канадский французский
/ 864 - арабский
/ 865 - Nordic
/ 866 - русский
/ 869 - греческий 2
/ 932 - японский (DBCS)
/ 936 - Упрощенный китайский (DBCS)
/ 949 - корейский (DBCS)
/ 950 - Традиционный китайский (DBCS)
/ 0 - включить все кодовые страницы, указанные выше и настроенные с помощью f_setcp ()
*/


#define FF_USE_LFN		0
#define FF_MAX_LFN		255
/* FF_USE_LFN переключает поддержку LFN (длинное имя файла).
/
/ 0: отключить LFN. FF_MAX_LFN не имеет никакого эффекта.
/ 1: Включить LFN со статическим рабочим буфером на BSS. Всегда НЕ потокобезопасен.
/ 2: Включить LFN с динамическим рабочим буфером в STACK.
/ 3: Включить LFN с динамическим рабочим буфером на HEAP.
/
/ Чтобы включить LFN, необходимо добавить в проект файл ffunicode.c. Функция LFN
/ Requiers определенный внутренний рабочий буфер занимает (FF_MAX_LFN + 1) * 2 байта и
/ дополнительный (FF_MAX_LFN + 44) / 15 * 32 байта, когда включена функция exFAT.
/ FF_MAX_LFN определяет размер рабочего буфера в кодовой единице UTF-16 и может
/ находиться в диапазоне от 12 до 255. Рекомендуется установить 255 для полной поддержки LFN
/  Спецификация.
/ Когда используете стек для рабочего буфера, позаботьтесь о переполнении стека. Когда использовать кучу
/ память для рабочего буфера, функции управления памятью, ff_memalloc () и
/ ff_memfree () в ffsystem.c, необходимо добавить в проект. */


#define FF_LFN_UNICODE	2//0
/* Эта опция переключает кодировку символов в API, когда включена LFN.
/
/ 0: ANSI / OEM в текущем CP (TCHAR = char)
/ 1: Юникод в UTF-16 (TCHAR = WCHAR)
/ 2: Unicode в UTF-8 (TCHAR = символ)
/ 3: Юникод в UTF-32 (TCHAR = DWORD)
/
/ Также эта опция будет влиять на поведение строковых функций ввода / вывода.
/ Когда LFN не включен, эта опция не действует. */


#define FF_LFN_BUF		255
#define FF_SFN_BUF		12
/* Этот набор параметров определяет размер членов имени файла в структуре FILINFO
/ который используется для считывания элементов каталога. Эти значения должны быть достаточными для
/ имена файлов для чтения. Максимально возможная длина прочитанного имени файла зависит
/ на кодировку символов. Когда LFN не включен, эти параметры не действуют. */


#define FF_STRF_ENCODE	3
/* Когда FF_LFN_UNICODE> = 1 с включенным LFN, строковые функции ввода / вывода, f_gets (),
/ f_putc (), f_puts и f_printf () преобразовывают кодировку символов в нем.
/ Эта опция выбирает предположение о кодировке символов в файле
/ читать / написано с помощью этих функций.
/
/ 0: ANSI / OEM в текущем CP
/ 1: Юникод в UTF-16LE
/ 2: Юникод в UTF-16BE
/ 3: Юникод в UTF-8
*/


#define FF_FS_RPATH		0
/* Эта опция настраивает поддержку относительного пути.
/
/ 0: отключить относительный путь и удалить связанные функции.
/ 1: Включить относительный путь. Доступны функции f_chdir () и f_chdrive ().
/ 2: функция f_getcwd () доступна в дополнение к 1.
*/


/*---------------------------------------------------------------------------/
/ Конфигурация Диска/Тома
/---------------------------------------------------------------------------*/

#define FF_VOLUMES		1
/* Количество томов (логических дисков), которые будут использоваться. (1-10) */


#define FF_STR_VOLUME_ID	0
#define FF_VOLUME_STRS		"RAM","NAND","CF","SD","SD2","USB","USB2","USB3"
/* FF_STR_VOLUME_ID переключает поддержку идентификатора тома в произвольных строках.
/ Когда FF_STR_VOLUME_ID установлен в 1 или 2, произвольные строки могут использоваться в качестве диска
/ номер в имени пути. FF_VOLUME_STRS определяет строки идентификатора тома для каждого
/ логические диски. Количество предметов не должно быть меньше FF_VOLUMES. действительный
/ Символами / для строк идентификатора тома являются A-Z, a-z и 0-9, однако они
/ по сравнению с регистронезависимым. Если FF_STR_VOLUME_ID> = 1 и FF_VOLUME_STRS
/ не определено, пользовательская таблица строк тома должна быть определена как:
/
/ const char * VolumeStr [FF_VOLUMES] = {"ram", "flash", "sd", "usb", ...
*/


#define FF_MULTI_PARTITION	0
/* Эта опция переключает поддержку нескольких томов на физическом диске.
/ По умолчанию (0) каждый номер логического диска привязан к одному и тому же физическому диску.
/ число и только том FAT, найденный на физическом диске, будет смонтирован.
/ Когда эта функция включена (1), каждый номер логического диска может быть привязан к
/ произвольный физический диск и раздел, перечисленные в VolToPart []. Также f_fdisk ()
/ funciton будет доступен. */


#define FF_MIN_SS		512
#define FF_MAX_SS		512
/* Этот набор параметров настраивает диапазон поддерживаемых размеров сектора. (512,
/ 1024, 2048 или 4096) Всегда устанавливайте 512 для большинства систем, общую карту памяти и
/  жесткий диск. Но для встроенной флэш-памяти может потребоваться большее значение, а некоторые
/ тип оптического носителя. Когда FF_MAX_SS больше, чем FF_MIN_SS, FatFs настраивается
/ для режима переменного размера сектора и должна быть реализована функция disk_ioctl ()
Команда / GET_SECTOR_SIZE. */

#define FF_USE_TRIM		0
/* Эта опция переключает поддержку ATA-TRIM. (0: отключить или 1: включить)
/ Чтобы включить функцию обрезки, команда CTRL_TRIM должна быть реализована в
/ disk_ioctl () функция. */


#define FF_FS_NOFSINFO	0
/* Если вам нужно знать правильное свободное место на томе FAT32, установите бит 0 этого
/ option и функция f_getfree () в первый раз после принудительного монтирования тома
/ полное сканирование FAT. Бит 1 управляет использованием последнего выделенного номера кластера.
/
/ bit0 = 0: использовать количество свободных кластеров в FSINFO, если доступно.
/ bit0 = 1: не доверять свободному количеству кластеров в FSINFO.
/ bit1 = 0: использовать последний выделенный номер кластера в FSINFO, если он доступен.
/ bit1 = 1: не доверять последнему выделенному номеру кластера в FSINFO.
*/



/*---------------------------------------------------------------------------/
/ Конфигурация системы
/---------------------------------------------------------------------------*/

#define FF_FS_TINY		0
/* Эта опция переключает крошечную конфигурацию буфера. (0: нормальный или 1: крошечный)
/ При крошечной конфигурации размер файлового объекта (FIL) сокращается до FF_MAX_SS байт.
/ Вместо буфера частного сектора, исключенного из файлового объекта, общий сектор
/ буфер в объекте файловой системы (FATFS) используется для передачи данных файла. */


#define FF_FS_EXFAT		0
/* Эта опция переключает поддержку файловой системы exFAT. (0: отключить или 1: включить)
/ Чтобы включить exFAT, также необходимо включить LFN. (FF_USE_LFN> = 1)
/ Обратите внимание, что включение exFAT исключает совместимость с ANSI C (C89). */


#define FF_FS_NORTC		1
#define FF_NORTC_MON	1
#define FF_NORTC_MDAY	1
#define FF_NORTC_YEAR	2018
/* Опция FF_FS_NORTC переключает функцию метки времени. Если в системе нет
/ любая функция RTC или действительная временная метка не нужны, установите FF_FS_NORTC = 1, чтобы отключить
/ функция отметки времени. Каждый объект, модифицированный FatFs, будет иметь фиксированную метку времени
/ определяется FF_NORTC_MON, FF_NORTC_MDAY и FF_NORTC_YEAR по местному времени.
/ Чтобы включить функцию отметки времени (FF_FS_NORTC = 0), функция get_fattime () должна быть
/ добавлен в проект для чтения текущего времени из часов реального времени. FF_NORTC_MON,
/ FF_NORTC_MDAY и FF_NORTC_YEAR не имеют никакого эффекта.
/ Эти параметры не влияют на конфигурацию только для чтения (FF_FS_READONLY = 1). */


#define FF_FS_LOCK		0
/* Опция FF_FS_LOCK переключает функцию блокировки файла для управления открытием дублированного файла
/ и незаконная операция по открытию объектов. Эта опция должна быть 0, когда FF_FS_READONLY
/ это 1.
/
/ 0: отключить функцию блокировки файлов. Чтобы избежать повреждения тома, прикладная программа
/ следует избегать незаконного открытия, удаления и переименования открытых объектов.
/> 0: включить функцию блокировки файлов. Значение определяет, сколько файлов / подкаталогов
/ может быть открыт одновременно под контролем блокировки файла. Обратите внимание, что файл
/ Блокировка управления не зависит от повторного входа. */


/* #include <somertos.h>	// O/S Определения */
#define FF_FS_REENTRANT	0
#define FF_FS_TIMEOUT	1000
#define FF_SYNC_t		HANDLE
/* Опция FF_FS_REENTRANT переключает повторный вход (потокобезопасный) FatFs
/ сам модуль. Обратите внимание, что независимо от этой опции, доступ к файлу
/ volume всегда входящий и функции управления громкостью, f_mount (), f_mkfs ()
/ и функции f_fdisk (), всегда не входящие. Только доступ к файлу / каталогу
/ до той же громкости находится под контролем этой функции.
/
/ 0: отключить повторный вход. FF_FS_TIMEOUT и FF_SYNC_t не имеют никакого эффекта.
/ 1: Включить повторный вход. Также пользователь предоставил обработчики синхронизации,
/ ff_req_grant (), ff_rel_grant (), ff_del_syncobj () и ff_cre_syncobj ()
/ функция, должна быть добавлена в проект. Образцы доступны в
/ option / syscall.c.
/
/ FF_FS_TIMEOUT определяет период ожидания в единицу времени.
/ FF_SYNC_t определяет O / S-зависимый тип объекта синхронизации. например HANDLE, ID, OS_EVENT*,
/ SemaphoreHandle_t и т. Д. Файл заголовка для определений O/S должен быть
/ включен где-то в сферу действия ff.h. */


/*--- Конец конфигурационного файла---*/
